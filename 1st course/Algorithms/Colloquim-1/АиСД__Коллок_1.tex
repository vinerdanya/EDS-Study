\documentclass[a4paper]{article}
\usepackage{header}
\begin{document}
\title{\LARGE{Алгоритмы и структуры данных-1}\\ Коллоквиум}
\author{Винер Даниил \href{https://t.me/danya_vin}{@danya\_vin}}
\date{Версия от \today}
\maketitle
\tableofcontents
\newpage
\section{Способы задания графов}
\subsection{Матрица смежности}
\textbf{Матрица смежности} — матрица графа $G=(V,E)$ размера $V\times V$, такая что на пересечении $i-$ой строки и $j-$ого столбца стоит 1, если есть ребро между вершинами $i$ и $j$, и 0 — если иначе\\[2mm]
\indentЕсли нужно узнать, есть ли ребро между \(i\) и \(j\), достаточно обратиться к \(A[i][j]\) — $O(1)$\\[2mm]
\indent\textbf{Затраты по памяти} — $O(V^2)$, так как храним матрицу размера $V\times V$

\subsection{Список смежности}
\textbf{Список смежности} — массив, в котором каждой вершине графа соответствует список, состоящий из соседей этой вершины\\[2mm]
\indent Пусть $V$ — это количество вершин, $E$ — количество рёбер. Изначально создается $V$ динамически расширяемых пустых векторов\\[2mm]
\indent При считывании ребра $A_i-B_i$ в вектор с номером $A_i$ добавляется ребро $B_i$ (если граф неориентированый, то еще в вектор с номером $B_i$ добавляется ребро $A_i$)\\[2mm]
\indent\textbf{Сложность построения} — $O(E)$\\[2mm]
\indent\textbf{Сложность нахождения всех соседей каждой вершины} — $O(V+E)$, так как мы проходим по всем вершинам за $V$ и просматриваем каждое ребро за $E$

\subsection{Список ребер}
\definition Список ребер — структура данных, представляющая собой набор из пар $A_i-B_i$, где $A_i,B_i$ — вершины графа\\[2mm]
\indent Порядок в списке ребер не важен \textbf{только в случае неориентированных} графов
\subsubsection*{Сложность нахождения всех соседей каждой вершины}
Если граф неориентирован, то оптимально будет сделать его ориентированным (помимо ребра $A_i-B_i$ добавить ребро $B_i-A_i$)
\begin{itemize}
    \item Для поиска всех соседей вершины (в неориентированном случае) надо перебрать все ребра и сравнить текущую вершину со второй вершиной ребра. $O(E)$
    \item Сортировка ребер — $O(E\log E)$
    \item Поиск первого соседа в списке ребер для одной вершины — $O(\log E)$
    \item Поиск первого соседа в списке ребер для всех — $O(V\log E)$
\end{itemize}
Так как обычно в графах $E\geqslant V$, то для поиска всех соседей всех вершин потребуется $O(E\log E)$

\newpage
\section{Обход в глубину}
\subsection{Обход в глубину}
\subsubsection*{Описание алгоритма}
Обход начинается с любой вершины графа. Из этой вершины мы переходим в одного из непосещенных соседей. Если все соседи посещены, то мы возвращаемся вдоль всего пройденного пути, пока не наткнемся на вершину, у которой есть непосещенный сосед. Алгоритм завершает работу, когда мы возвращаемся в исходную вершину и все ее соседи посещены\\[2mm]
Отметим, что в общем случае, когда неизвестно связный граф или нет, нужно запустить обход в цикле по всем вершинам
\subsubsection*{Применение алгоритма}
\begin{enumerate}
    \item Поиск случайного пути в лабиринте
    \item Решение задач, связанных с построением маршрута: в сети, на карте, в сервисах покупки билетов и так далее
    \item Проврека на наличие циклов, топологическая сортировка
\end{enumerate}
\subsubsection*{Асимптотика}
\label{dfs_asimp}
Сложность по памяти — $O(V)$, где $V$ — количество вершин графа\\[2mm]
Временная сложность зависит от представления графа: матрица смежности, список ребер или список смежности\\[2mm]
\indent Рассмотрим каждый вариант:
\begin{enumerate}
    \item Список смежности — $O(V+E)$
    \begin{itemize}
        \item Вершины посещаются (проверяются на посещенность) только один раз, что составляет $O(V)$
        \item Каждое ребро проверяется ровно один раз, что составляет $O(E)$
    \end{itemize}
    \item Матрица смежности — $O(V^2)$
    \begin{itemize}
        \item Вся матрица имеет размер $V\times V$
    \end{itemize}
    \item Список рёбер — $O(E\log E + E)$ при предварительной сортировке и бинарном поиске
\end{enumerate}
\subsubsection*{Пример}
\begin{center}
    \includegraphics[width=0.8\linewidth]{dfs.png}
    \label{dfs}
\end{center}
% \subsubsection*{Псевдокод}
% \begin{lstlisting}
% void dfs(int v){
%     used[v] = 1;
%     for (auto to : gr[v]){
%         if (!used[to]){
%             dfs(to);
%         }
%     }
% }
% \end{lstlisting}

\subsection{Связность неориентированного графа}
\textbf{Связный граф} — граф, в котором существует путь от любой вершины до любой другой вершины
\subsubsection*{Проверка неориентированного графа на связность}
Запуск DFS от любой из вершин графа
\begin{itemize}
    \item Запускаем DFS из любой вершины
    \item После DFS проверяем, посещены ли все вершины. Если да — граф связный, нет — несвязный
    \item Сложность по памяти будет зависеть от способа хранения графа
    \item Сложность по времени — $O(V+E)$
\end{itemize}

\subsection{Сильная связность ориентированного графа}
\definition В ориентированном графе сильная связность требует, чтобы для любых двух вершин $u$ и $v$ существовал ориентированный путь $u\rightarrow v$ и $v\rightarrow u$\\[2mm]
Для проверки нужно запустить 2 DFS
\begin{enumerate}
    \item Запускаем DFS на исходном графе
    \begin{itemize}
        \item Выбираем любую вершину $v$
        \item Запускаем из неё DFS, помечая все достижимые вершины
        \item После завершения проверяем: если посетили не все $V$ вершин, то граф не сильно связен
    \end{itemize}
    \item Второй DFS в транспонированном графе
    \begin{itemize}
        \item Строим транпонированный граф, то есть все ребра $u\rightarrow v$ превращаются в $v\rightarrow u$
        \item Запускаем DFS из той же вершины $v$
        \item Снова убеждаемся, что посетили все вершины
    \end{itemize}
\end{enumerate}
Если во время обоих обходов мы посетили все вершины, то граф является сильно связным

\subsection{Поиск компонент связности в графе}
\label{2.3}
\textbf{Компонента связности графа} — подмножество вершин и соединяющих их ребер, такое что есть путь из каждой вершины в каждую\\[2mm]
\indent \textbf{Алгоритм поиска компоненты связности}
Можно раскрасить граф в компоненты связности. Каждой вершине ставится в соответствие номер компоненты связности, к которой относится вершина\\[2mm]
\indent \textbf{Реализация происходит через DFS}\\
Может потребоваться несколько запусков поиска в глубину. Поэтому поиск проводим через цикл, перебирающий все вершины
\begin{itemize}
    \item Заводим массив длинной $V$ для хранения цвета каждой вершины
    \item При входе в DFS красим вершину в текущий цвет (\code{color[v] = component})
    \item Если очередная вершина не покрашена, то счетчик количества компонент связности увеличивается и запускается DFS для этой вершины со значением цвета равным текущему значению счетчика
\end{itemize}
\textbf{Затраты по памяти} составят $O(V)$ под массив цветов и стек рекурсии (или очередь при итеративном обходе), плюс хранение графа\\[2mm]

\textbf{Сложность по времени:} $O(V + E)$ при хранении графа списком смежности, потому что каждый DFS обходит каждую вершину и каждое ребро не более одного раза, а цикл по всем вершинам добавляет лишь проверку цвета: $O(V+E)$

\subsection{Поиск цикла в графе}
Чтобы найти цикл в графе нужно раскрасить его в три цвета:
\begin{itemize}
    \item \textbf{Белый} — вершина непосещенная
    \item \textbf{Серый} — DFS вошел в вершину, но не обработал всех соседей
    \item \textbf{Черный} — Все соседи вершины посещены и помечены черным
\end{itemize}
$$\boxed{\text{Если в графе есть обратные ребра, т.е. ребра ведущие в серую вершину, то в графе есть цикл}}$$
\subsubsection*{Алгоритм}
\begin{itemize}
    \item В каждый момент времени серым цветом будут помечены вершины, лежащие на пути \dfs от стартовой вершины до текущей
    \item Если из текущей вершины $u$ есть ребро в серую вершину $v$, то в графе есть цикл, т.к. существует путь от $v$ до $u$ ($v$ лежит на пути от стартовой вершины до $u$) и путь от $u$ до $v$, проходящий по одному ребру
\end{itemize}
\textbf{Временная сложность:} $O(V + E)$, поскольку каждая вершина и каждое ребро обрабатываются не более одного раза\\[2mm]
\textbf{Память:} $O(V)$ под массив меток и стек рекурсии.
\subsubsection*{Восстановление цикла}
Допустим, для $u$ нашелся серый сосед $v$, тогда запоминаем номер $v$ и выходим из рекурсивной функции, запоминая номера вершин, пока не дойдем до вершины, в которой нашелся цикл 
 
\subsection{Проверка графа на двудольность}
\textit{Примечание.} Граф — двудольный тогда и только тогда, когда все циклы в графе имеют четную длину\\[2mm]
\textbf{Алгоритм}
\begin{itemize}
    \item Выбираем произвольную вершину и красим ее в цвет \textit{color}
    \item Всех соседей этой вершины красим в цвет $3-color$
    \item Соседей соседей — в цвет \textit{color} и т.д.
    \item Если в какой-то момент сосед вершины уже покрашен в тот же цвет, что и вершина, то алгоритм завершает работу, так как граф не двудольный, потому что есть циклы нечетной длины
\end{itemize}
Если граф не является связным, то нужно запустить \dfs из каждой вершины каждой компоненты связности (как в п. \ref{2.3})


\subsection{Диаметр и центр дерева}
\textbf{Диаметр дерева} — максимальная длина (в рёбрах) кратчайшего пути в дереве между любыми двумя вершинами\\[2mm]
\indent\textbf{Центр дерева} — вершины (одна или две) максимально удаленные от других вершин дерева\\
\indent\indent\textit{Примечание.} Центр можно понимать так: это вершина дерева, такая что при подвешивании дерева за нее глубина дерева минимальна
\subsubsection*{Алгоритм поиска диаметра дерева}
Требуется использовать два \dfs
\begin{itemize}
    \item Берем любую вершину дерева (пусть это $a$) и ищем самую удаленную от нее вершину $b$ с помощью \dfs
    \item Из вершины $b$ запускаем \dfs и ищем самую удаленную от нее вершину (пусть это $c$)
    \item Путь из $b$ в $c$ — диаметр дерева
\end{itemize}

% \begin{lstlisting}
%     std::vector<node> find_diameter() {
%         std::vector<node> ans, path;
%         std::vector<int> used(gr_.size(), 0);

%         std::function<void(node v)> dfs = [&] (node v) {
%             used[v] = true;
%             path.emplace_back(v);
%             for (const auto& to : gr_[v]) {
%                 if (!used[to]) {
%                     dfs(to);
%                 }
%             }
%             if (ans.size() < path.size()) {
%                 ans = path;
%             }
%             path.pop_back();
%         };
%         dfs(0);
%         used.assign(gr_.size(), 0);
%         dfs(ans.back());
%         return ans;
%     }
% \end{lstlisting}

\newpage
\section{Задача построения дерева кратчайших расстояний}
\subsection{Обход в ширину}
\subsubsection*{Наивный алгоритм}
Создаем массив, заполняем его бесконечностями. Для начальной вершины установим значение 0\\[2mm]
\indent Выполняем $v-1$ шаг. Нужно перебрать все вершины и выбрать те, которые находятся на расстоянии равном номеру шага, а также пометить все соседние вершины числом на 1 большим, чем номер текущего шага
\begin{itemize}
    \item На нулевом шаге выбираем начальную вершину и помечаем ее соседей 1
    \item Затем выбираем вершины, находящиеся на расстоянии 1 и их непомечанных соседей помечаем 2 и т.д.
\end{itemize}
\textbf{Сложность по времени} — $O(V^2+E)$, так как мы сделаем $V$ шагов, переберем $V$ вершин, а также просмотрим все ребра\\[2mm]
\textbf{Сложность по памяти} — $O(V)$ заводится под массив расстояний
\subsubsection*{Реализация через очередь}
\begin{enumerate}
  \item Инициализировать для всех $u$: $\text{dist}[u]=\infty$, $\text{visited}[u]=\text{false}$.
  \item $\text{dist}[start]=0$, $\text{visited}[start]=\text{true}$, положить $start$ в очередь $q$.
  \item Пока $q$ не пуста:
    \begin{itemize}
      \item $u = q.\text{pop}()$.
      \item Для каждого соседа $v$ из $\mathrm{adj}[u]$:
        \begin{itemize}
          \item Если $\neg\text{visited}[v]$:
            \begin{itemize}
              \item $\text{visited}[v]=\text{true}$,
              \item $\text{dist}[v]=\text{dist}[u]+1$,
              \item $q.\text{push}(v)$.
              \item Если $v$ — искомая вершина, выйти из всех циклов.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{enumerate}

\textbf{Сложности:}
\begin{itemize}
  \item Время: $O(V + E)$.
  \item Память: $O(V)$ под очередь, массивы \texttt{dist} и \texttt{visited}, плюс хранение графа.
\end{itemize}

\subsubsection*{Применение алгоритма}
\begin{enumerate}
    \item Для поиска кратчайшего пути в неявно заданных и невзвешенных графах
    \item Для обнаружения кратчайших путей и минимальных покрывающих деревьев
    % \item Для построения индексов веб-страниц
\end{enumerate}
\indent \textit{Белый} — еще не посещенные вершины, \textit{черный} — уже посещенный, \textit{красный} — обрабатывающиеся в данный момент (в начале очереди), \textit{серый} — вершины, находящиеся в очереди
\begin{center}
    \includegraphics[width=1\linewidth]{bfs.png}
    \label{bfs}
\end{center}

\subsection{Алгоритм Дейкстры}
\textit{Attention:} веса ребер должны быть неотрицательными, иначе алгоритм не будет работать корректно
\subsection*{Случай для плотного графа}
Создадим такие массивы
\begin{itemize}
    \item \code{dist} — размером $v+1$. В нем для каждой вершины хранится текущая длина кратчайшего пути от начальной вершины $s$. (\code{d[s] = 0}, а все остальное — inf)
    \item \code{visited} — размером $v+1$. Хранит иформацию о том, обработана вершина или нет
\end{itemize}
Алгоритм состоит из $v-1$ шага. На каждом шаге делаем следующее

Для i=1\ldots V:
  \begin{enumerate}
    \item Выбрать необработанную вершину $v$ с минимальным \code{dist[v]}.
    \item Пометить $v$ как обработанную и выполнить релаксацию всех ребер $(v \to u)$:
      \[
        \code{dist[u]} = \min(\code{dist[u]}, \code{dist[v]} + w(v,u)).
      \]
  \end{enumerate}

% \textit{Красный} — вершины, для которых будет произведена релаксация, \textit{серый} — обработанные вершины\\
\begin{center}
    \includegraphics[width=0.8\linewidth]{dijkstra.png}
    \label{dijkstra}
\end{center}
\textit{Красный} — вершины, для которых будет произведена релаксация, \textit{серый} — обработанные вершины\\[2mm]
\textbf{Сложность со списком смежности} — $O(V^2+E)$, так как мы на каждом из $v-1$ шагов ищем минимум из $V$ чисел для вершин и просматриваем каждое ребро один раз\\[2mm]
\textbf{Сложность с матрицей смежности} — $O(V^2)$
\subsection*{Случай для разряженного графа}
\indent \textit{Reminder.} Разряженным называется граф, у которого количество ребер значительно меньше, чем $V^2$ \\[2mm]
Алгоритм Дейкстры для разреженных графов работает следующим образом:
\begin{enumerate}
    \item Инициализация:
    \begin{itemize}
        \item Задаётся начальная вершина, от которой будут рассчитываться кратчайшие пути
        \item Все расстояния до остальных вершин инициализируются как бесконечность, кроме начальной вершины, для которой расстояние равно нулю
        \item Создаётся структура данных, например, \code{ordered set} или куча, для хранения и быстрого доступа к вершинам и их текущим кратчайшим расстояниям
    \end{itemize}
    \item Пока есть непосещённые вершины:
    \begin{itemize}
        \item Выбирается вершина с минимальным текущим расстоянием (с использованием кучи или \code{ordered set})
        \item Эта вершина помечается как посещённая
        \item Для каждой соседней вершины, смежной с текущей:
        \begin{itemize}
            \item Рассчитывается новое потенциальное расстояние как сумма текущего расстояния до рассматриваемой вершины и веса ребра между текущей вершиной и соседней
            \item Если новое расстояние меньше известного расстояния до соседней вершины:
            \begin{itemize}
                \item Обновляется расстояние до соседней вершины
                \item В \code{ordered set} или куче обновляется информация о расстоянии до этой вершины
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Обновление структуры данных:
    \begin{itemize}
        \item При обновлении расстояний до соседних вершин, в структуре данных (куче или \code{ordered set}) происходит операция удаления старого значения и добавления нового значения, что обеспечивает эффективность алгоритма
        \item В случае использования кучи без изменения элементов (например, \code{priority queue}) просто добавляются новые значения, а устаревшие игнорируются
    \end{itemize}
\end{enumerate}
\indent Процесс повторяется, пока не будут посещены все вершины или не будут определены кратчайшие пути до всех достижимых вершин\\[2mm]
\indent \textbf{Сложность —} $O(E\log{V} + V\log{V})$. Узнаем минимум за $O(1)$ (удаление минимума тратит $O(\log{V})$), изменяем элементы за $O(\log{V})$. Для большинства графов сложность будет просто $O(E\log{V})$, так как каждое из $E$ ребер может привести к уменьшению пути и изменению значения в set\\[2mm]
\indent В итоге массив расстояний содержит кратчайшие пути от начальной вершины до всех остальных вершин


\subsection{Алгоритм Форда-Беллмана}
Создадим такой массив
\begin{itemize}
    \item \code{dist} — размером $v+1$. Массив кратчайших расстояний. (\code{d[s] = 0}, а все остальное — inf)
\end{itemize}
Алгоритм состоит из $v-1$ шага. Пусть есть ребро $(u,v)$ и его вес $w$. На каждом шаге перебираем все ребра и проводим релаксацию по этому ребру, то есть
\begin{lstlisting}
    if (dist[v] > dist[u] + w && dist[u] != inf){
        dist[v] = dist[u] + w
    }
\end{lstlisting}
\subsubsection*{Применение алгоритма}
Алгоритм хорош в поиске кратчайших путей от одной вершины до всех остальных на разряженных графах, если в графе есть отрицательные ребра\\[2mm]
\textbf{Временная сложность:} $O(V \times E)$\\[2mm]
\textbf{Слоность по памяти:} $O(V + E)$ 
\begin{itemize}
  \item $O(V)$ под массив \texttt{dist};
  \item $O(E)$ под список рёбер.
\end{itemize}


\subsection{Алгоритм Флойда–Уоршалла}
Работаем с матрицей размера $V\times V$, где
\[
  \mathrm{dist}[i][j] =
    \begin{cases}
      w(i,j), & \text{если }(i\to j)\text{ есть ребро},\\
      0,      & i=j,\\
      \infty,& \text{иначе}.
    \end{cases}
\]

\textbf{Основной тройной цикл:}
\begin{lstlisting}
    for k in 1..V:
        for i in 1..V:
            for j in 1..V:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

\end{lstlisting}

\textbf{Обнаружение отрицательного цикла:}\\
Если после выполнения алгоритма \(\mathrm{dist}[i][i]<0\) для некоторого \(i\), в графе есть отрицательный цикл.

\subsubsection*{Применение}
\begin{itemize}
  \item Поиск кратчайших путей «каждый→каждый»
\end{itemize}

\textbf{Сложности:}
\begin{itemize}
  \item Время: \(O(V^3)\).
  \item Память: \(O(V^2)\).
\end{itemize}

\newpage
\section{Задача union — find}
\subsection{Задача union — find}
Пусть у нас есть $N$ элементов, занумерованных от 1 до $N$. Изначально каждый элемент находится в своем отдельном множестве (также занумерованных от 1 до $N$). Нам необходимо поддерживать такие операции:
\begin{itemize}
    \item \code{find(x)} — найти номер множетсва, в котором лежит $x$
    \item \code{union(x, y)} — объединить множества, содержащие $x$ и $y$
    \item Можно добавить, но необязательно:
    \begin{itemize}
        \item \code{make(x)} — создает новое множество, содержащее $x$ 
    \end{itemize}
\end{itemize}
\begin{center}
    \includegraphics[width=0.6\linewidth]{DSU_1_Example.png}
    \label{union-find}
\end{center}

\subsection{Наивная реализация}
\begin{enumerate}
    \item Создаем массив с индексами от 1 до $N$
    \begin{itemize}
        \item Индекс означает номер элемента
        \item Значение по индексу — номер множества, к которому относится элемент
    \end{itemize}
    \item Операция \code{find(x)}
    \begin{itemize}
        \item Нужно вернуть содержимое ячейки с номером $x$
        \item \textbf{Сложность} — $O(1)$
    \end{itemize}
    \item Операция \code{union(x, y)}
    \begin{itemize}
        \item Узнаем номера множеств, содеражащих эти элементы (пусть это $a$ и $b$ соответственно)
        \item Проходим по всему массиву и заменяем значения $b$ на $a$
        \item \textbf{Сложность одной операции} — $O(N)$
        \item \textbf{Сложность объединения всех множеств} — $O(N^2)$
    \end{itemize}
\end{enumerate}

\subsection{Реализация с использованием линейных списков}
Идея этой реализации заключается в том, что мы заводим второй масиив, на индексах которого стоят номера множеств, а по индексу хранится список элементов соответствующего множества\\[2mm]
\indent Тогда при вызове \code{union(x, y)} мы делаем так: \code{max(x, y) += min(x, y)}
\subsubsection*{Сложность}
Так как мы храним второй масиив, то мы \textit{теряем в памяти}, однако алгоритм будет работать \textit{быстрее}, за $O(N\log N)$, так как делаем $O(\log N)$ шагов на кажом шаге $O(N)$ для объединения множеств
\begin{center}
    \includegraphics[width=0.75\linewidth]{linlist2.png}
    \label{union-find-lin}
\end{center}

\subsection{Система непересекающихся множеств}
Идея заключается в хранении каждого множества в виде дерева\\[2mm]
\indent Мы имеем один единственный массив предков \code{p}. Индексы в нем — номера элементов, а по индексу хранится номер предка
\begin{center}
    \includegraphics[width=0.6\linewidth]{snm.png}
    \label{dsu}
\end{center}
В данном примере, петли означают, что это корень дерева, а в \code{p} на позицию с номером корня записывается значение самого корня\\[2mm]
Вместо этого, в \code{p} на позицию корня можно поставить $-1$, суть не изменится\\[2mm]
Тогда операции \code{find(x)} и \code{union(x, y)} можно реализовать так:
\begin{lstlisting}
    int find(x){
        while (p[v] != -1){
            v = p[v]
        }
        return v
    }
    
    void union(x, y){
        p[find(x)] = find(y)
    }
\end{lstlisting}
\indent\textbf{Сложность} — $O(N^2)$
\subsubsection{Сжатие путей}
Идея заключается в том, что когда мы найдём искомого предка $p$ множества (с помощью \code{find(x)}), то запомним, что у вершины $x$ и всех пройденных по пути вершин — именно этот предок $p$. Проще всего это сделать, перенаправив их {\rm parent}[] на эту вершину $p$\\[2mm]
\indent Теперь в массиве предков для каждой вершины там может храниться не непосредственный предок, а предок предка, предок предка предка, и т.д\\[2mm]
\indent \textbf{Сложность} — $O(\log N)$

\subsubsection{Объединение деревьев}
Идея: нужно подвешивать дерево с большей глубиной к дереву с меньшей глубиной\\[2mm]
\indent Для каждого дерева храним его глубину в массиве\\[2mm]
\indent \textbf{Сложность} — $O(\log N)$

\subsection{Алгоритм Краскала}
\begin{itemize}
    \item Отсортируем все ребра по возрастанию
    \item Каждая вершина находится в своем отдельном множестве
    \item В остовное дерево берем те ребра, которые соединяют разные множества вершин
    \item При добавлении ребра происходит объединение множеств
\end{itemize}
Алгоритм используется для построения минимального остовного дерева в графе\\[2mm]
Реализовать представленный алгоритм проще всего с помощью СНМ. Необходимо отсортировать ребра по неубыванию по их весам. Далее мы каждую вершину можем поместить в свое собственное дерево, то есть, создаем некоторое множество подграфов. Дальше итерируемся по всем ребрам в отсортированном порядке и смотрим, принадлежат ли инцидентные вершины текущего ребра разным подграфам с помощью функции find() или нет, если оба конца лежат в разных компонентах, то объединяем два разных подграфа в один с помощью функции union().\\[2mm]
Итоговая сложность составит $O(E\log V+V+E)=O(E\log V)$, где $O(E\log V)$ - сортировка, $O(V)$ — создание отдельных множеств, $O(1)$ — find() и union()

\newpage
\section{Дерево отрезков}
\subsection{Дерево отрезков}
Дан массив $a$ из $n$ целых чисел, и требуется отвечать на запросы двух типов:
\begin{enumerate}
    \item Изменить значение в ячейке (т. е. реагировать на присвоение \code{a[k] = x})
    \item Вывести сумму элементов $a_i$ на отрезке с $l$ по $r$
\end{enumerate}
Несколько изменим массив
\begin{itemize}
    \item Посчитаем сумму всего массива и где-нибудь запишем
    \item Разделим его пополам, посчитаем сумму на половинах и тоже где-нибудь запишем
    \item Каждую половину разделим пополам ещё раз, и т.д., пока не придём к отрезкам длины 1
\end{itemize}
\begin{center}
    \includegraphics[width=0.9\linewidth]{segtree-example.jpg}
    \label{segtree-ex}
\end{center}
Корень этого дерева соответствует отрезку $[0, n)$, а каждая вершина (не считая листьев) имеет ровно двух сыновей, которые тоже соответствуют каким-то отрезкам

\subsection{Операции на отрезке}
Здесь представлены операции на отрезке, реализованные с помощью указателей. Эта реализация не самая эффективная, но самая простая, решающая большинство задач. Подробнее о других реализациях \href{http://e-maxx.ru/algo/segment_tree}{тут} и \href{https://codeforces.com/blog/entry/18051}{тут}
% \indent Можно ввести нумерацию вершин и расположить их в массиве, подробнее об этом \href{http://e-maxx.ru/algo/segment_tree}{тут} и \href{https://codeforces.com/blog/entry/18051}{тут}
\subsubsection{Построение}
Строить дерево отрезков можно рекурсивным конструктором, который создает детей, пока не доходит до листьев\\[2mm]
\indent Если изначально массив не нулевой, то можно параллельно с проведением ссылок насчитывать суммы\\[2mm]
\indent \textbf{Сложность} — $O(n)$
\begin{lstlisting}
Segtree(int lb, int rb) : lb(lb), rb(rb) {
    if (lb + 1 == rb)
        s = a[lb];
    else {
        int t = (lb + rb) / 2;
        l = new Segtree(lb, t);
        r = new Segtree(t, rb);
        s = l->s + r->s;
    }
}
\end{lstlisting}

\subsubsection{Изменение}
Для запроса прибавления будем рекурсивно спускаться вниз, пока не дойдем до листа, соответствующего элементу $k$, и на всех промежуточных вершинах прибавим $x$:
\begin{lstlisting}
void add(int k, int x) {
    s += x;
    if (l){
        if (k < l->rb)
            l->add(k, x);
        else
            r->add(k, x);
    }
}
\end{lstlisting}
\indent \textbf{Сложность} — $O(\log n)$

\subsubsection{Сумма}
Нужно делать разбор случаев, как отрезок запроса пересекается с отрезком вершины:
\begin{enumerate}
    \item Если лежит полностью в отрезке запроса, вывести сумму
    \item Если не пересекается с отрезком запроса, вывести ноль
    \item else: рекурсивно запускаемся от детей
\end{enumerate}
\begin{lstlisting}
int sum(int lq, int rq) {
    if (lb >= lq && rb <= rq)
        return s;
    if (max(lb, lq) >= min(rb, rq))
        return 0;
    return l->sum(lq, rq) + r->sum(lq, rq);
}
\end{lstlisting}
\indent \textbf{Сложность} — $O(\log n)$. На каждом уровне дерева отрезков, наша рекурсивная функция могла посетить максимум четыре отрезка; тогда, учитывая оценку $O (\log n)$ для высоты дерева, мы получаем асимптотику времени работы алгоритма


\subsection{Применение дерева отрезков}
Дерево отрезков может применяться в таких задачах, как
\begin{itemize}
    \item поиск суммы на подотрезке
    \item поиск минимума/максимума на отрезкее
    \item массовые изменения массивов (например, добавление элемента ко всем элементам сразу)
\end{itemize}

\newpage
\section{Дерево поиска}
\textbf{\textit{Бинарное дерево поиска}} — дерево, для которого выполняются следующие свойства:
\begin{itemize}
\item У каждой вершины не более двух детей
\item Все вершины обладают \textit{ключами}, на которых определена операция сравнения (например, целые числа или строки)
\item У всех вершин \textit{левого} поддерева вершины $v$ ключи \textit{не больше}, чем ключ $v$
\item У всех вершин \textit{правого} поддерева вершины $v$ ключи \textit{больше}, чем ключ $v$
\item Оба поддерева — левое и правое — являются двоичными деревьями поиска
\end{itemize}
В \textit{небинарных} (\sout{нетрадиционных}) деревьях количество детей может быть больше двух, и при этом в «более левых» поддеревьях ключи должны быть меньше, чем «более правых»\\[2mm]
\indent Для работы с деревьями поиска нужно создать структуру
\begin{lstlisting}
struct Node:
  T key                    // key of the node
  Node left                // pointer to the left child
  Node right               // pointer to the right child
  Node parent              // pointer to the parent
\end{lstlisting}
\subsection{Поиск элемента}
Нужна функция, прнимающая корень дерева и искомый ключ
\begin{itemize}
    \item Для каждого узла сравниваем значение его ключа с искомым ключом
    \item Если ключи одинаковы, то функция возвращает текущий узел
    \item В противном случае функция вызывается рекурсивно для левого или правого поддерева
\end{itemize}
\begin{lstlisting}
Node search(x : Node, k : T):
   if x == null or k == x.key
      return x
   if k < x.key
      return search(x.left, k)
   else
      return search(x.right, k)
\end{lstlisting}
\textbf{Сложность в худшем случае} — $O(h)$ ($h$ — высота дерева), так как узлы, которые посещает функция образуют нисходящее дерево. Такое возможно, когда дерево является «бамбуком»\\[2mm]
\textbf{Сложность при оптимизации} — $O(\log N)$. Если изменить способ хранения дерева, например сразу при проходе до какого-то ключа записать его как ключ ко всем вершинам в пути, то сложность снизится

\subsection{Вставка элемента}
Почти то же самое, что поиск элемента, но теперь при обнаружении у элемента отсутствия ребенка нужно подвесить на него вставляемый элемент
\begin{lstlisting}
Node insert(x : Node, z : T):               // x - root of the subtree, z - key to be inserted
   if x == null 
      return Node(z)                        // attach a Node with key = z
   else if z < x.key
      x.left = insert(x.left, z)
   else if z > x.key
      x.right = insert(x.right, z)
   return x
\end{lstlisting}

\subsection{Удаление элемента}
Рассмотрим три случая при рекурсивной реализации
\begin{enumerate}
    \item Удаляемый элемент находится в \textit{левом} поддереве текущего поддерева
    \begin{itemize}
        \item тогда нужно рекурсивно удалить элемент из нужного поддерева
    \end{itemize}
    \item Удаляемый элемент находится в \textit{правом} поддереве
    \begin{itemize}
        \item тогда нужно рекурсивно удалить элемент из нужного поддерева
    \end{itemize}
    \item Удаляемый элемент находится в \textit{корне}, то два случая:
    \begin{itemize}
        \item имеет два дочерних узла
        \begin{itemize}
            \item нужно заменить его минимальным элементом из правого поддерева и рекурсивно удалить этот минимальный элемент из правого поддерева
        \end{itemize}
        \item имеет один дочерний узел
        \begin{itemize}
            \item нужно заменить удаляемый элемент потомком
        \end{itemize}
    \end{itemize}
\end{enumerate}
\begin{lstlisting}
Node delete(root : Node, z : T):    // root of subtree, key to delete
  if root == null
    return root
  if z < root.key
    root.left = delete(root.left, z)
  else if z > root.key
    root.right = delete(root.right, z)
  else if root.left != null and root.right != null
    root.key = minimum(root.right).key
    root.right = delete(root.right, root.key)
  else
    if root.left != null
      root = root.left
    else if root.right != null
      root = root.right
    else
      root = null
  return root
\end{lstlisting}
% \subsubsection*{Еще один вариант объяснения}
% \begin{enumerate}
%     \item Если пытаемся удалить лист или какую-то вершину в одном из поддеревьев, то все хорошо. Просто вырезаем вершину и на ее место ставим потомка и всех потомков потомка
%     \item Если же пытаемся удалить 
% \end{enumerate}

\newpage
\section{LCA (TBA)}

\end{document}